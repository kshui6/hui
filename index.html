<html>
 <head> 
  <title>图片序列播放器（横屏）</title> 
  <style>
        body {
            margin: 0;
            height: 100vh;
            background-color: #f0f0f0;
            touch-action: none;
            overflow: hidden;
            position: relative;
        }
        #imageContainer {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #fff;
            padding: 0;
            margin: 0;
        }
        #sequenceImage {
            width: auto;
            height: 100vh;
            max-width: 100vw;
            object-fit: cover;
        }
        .hint {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #333;
            font-family: Arial, sans-serif;
            font-size: 16px;
            padding: 6px 12px;
            background-color: rgba(255,255,255,0.9);
            border-radius: 4px;
            z-index: 10;
        }
        .speed-control {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            height: 180px;
            width: 12px;
            background-color: #ddd;
            border-radius: 6px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            z-index: 10;
        }
        .speed-track {
            width: 100%;
            height: 100%;
            position: relative;
        }
        .speed-thumb {
            width: 30px;
            height: 30px;
            background-color: #4a90e2;
            border-radius: 50%;
            position: absolute;
            left: 50%;
            top: 0;
            transform: translateX(-50%);
            box-shadow: 0 3px 8px rgba(0,0,0,0.2);
            cursor: pointer;
            z-index: 11;
        }
        .speed-thumb::after {
            content: '';
            position: absolute;
            top: -20px;
            left: -20px;
            right: -20px;
            bottom: -20px;
        }
        .speed-labels {
            position: fixed;
            right: 60px;
            top: calc(50% - 90px);
            height: 180px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            font-family: Arial, sans-serif;
            font-size: 18px;
            color: #555;
            z-index: 10;
        }
        .frame-control {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            height: 180px;
            width: 12px;
            background-color: #ddd;
            border-radius: 6px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            z-index: 10;
        }
        .frame-track {
            width: 100%;
            height: 100%;
            position: relative;
        }
        /* 左侧滑块图片放大样式 */
        .frame-thumb {
            width: 80px;  /* 显著增大宽度（原40px） */
            height: auto; /* 保持图片比例 */
            position: absolute;
            left: 50%;
            top: 100%; /* 初始位置在最底部 */
            transform: translateX(-50%) translateY(-30px); /* 水平居中并上移20px */
            cursor: pointer;
            z-index: 11;
            transition: top 0.2s ease-out;
        }
        .frame-thumb::after {
            content: '';
            position: absolute;
            top: -20px;
            left: -20px;
            right: -20px;
            bottom: -20px;
        }
        .frame-labels {
            position: fixed;
            left: 100px; /* 调整标签位置，避免被放大的图片遮挡 */
            top: calc(50% - 90px);
            height: 180px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            font-family: Arial, sans-serif;
            font-size: 18px;
            color: #555;
            z-index: 10;
        }
    </style> 
  <script src="js/jq.js"></script> 
 </head> 
 <body id="v1"> 
  <div id="imageContainer"> 
   <img id="sequenceImage" src="1.png" alt="序列图片"> 
  </div> 
  <div id="v2" class="hint">
    长按屏幕开始操妹妹，松手停止 
  </div> 
  <div id="v3" class="speed-control"> 
   <div id="v4" class="speed-track"> 
    <div class="speed-thumb" id="speedThumb" style="top: 6.25%;"></div> 
   </div> 
  </div> 
  <div id="v5" class="speed-labels"> 
   <span id="v6">快</span> 
   <span id="v7">慢</span> 
  </div> 
  <div id="v8" class="frame-control"> 
   <div class="frame-track" id="frameTrack"> 
    <!-- 左侧滑块图片 --> 
    <img class="frame-thumb" id="frameThumb" src="penis.png" alt="滑块图片" style="top: 100%;"> 
   </div> 
  </div> 
  <div id="v9" class="frame-labels"> 
   <span id="v10">插入</span> 
   <span id="v11">抽出</span> 
  </div> 
  <script>
        const imgElement = document.getElementById('sequenceImage');
        const container = document.getElementById('imageContainer');
        const speedThumb = document.getElementById('speedThumb');
        const speedTrack = document.querySelector('.speed-track');
        const frameThumb = document.getElementById('frameThumb');
        const frameTrack = document.getElementById('frameTrack');
        
        // 速度参数设置
        let frameDelay = 25;
        const minDelay = 20;
        const maxDelay = 100;
        let isPlaying = false;
        let currentIndex = 1;
        let targetIndex = 1; // 目标帧索引
        let direction = 1;
        let animationId = null;
        let isDragging = false;
        let isFrameDragging = false;
        let frameAnimationFrame = null;
        const frameTransitionSpeed = 8; // 降低数值，减小延迟（数值越小反应越快）
        
        // 核心逻辑：图片切换与滑块动画同步延迟
        function playNextFrame() {
            if (isFrameDragging) {
                // 拖动时直接同步
                currentIndex = targetIndex;
            } else {
                // 自动播放时逐步接近目标帧（步长增大，减小延迟感）
                if (currentIndex < targetIndex) {
                    currentIndex = Math.min(currentIndex + 2, targetIndex); // 每次移动2帧
                } else if (currentIndex > targetIndex) {
                    currentIndex = Math.max(currentIndex - 2, targetIndex); // 每次移动2帧
                } else {
                    // 到达目标帧后继续自动播放逻辑
                    currentIndex += direction;
                    if (currentIndex > 12) {
                        currentIndex = 12;
                        direction = -1;
                    } else if (currentIndex < 1) {
                        currentIndex = 1;
                        direction = 1;
                    }
                    targetIndex = currentIndex;
                }
            }
            
            imgElement.src = `${currentIndex}.png`;
            updateFrameThumbPositionWithDelay(targetIndex);
            
            if (isPlaying) {
                animationId = setTimeout(playNextFrame, frameDelay);
            }
        }

        function startPlay() {
            if (!isPlaying) {
                isPlaying = true;
                playNextFrame();
            }
        }

        function stopPlay() {
            if (isPlaying) {
                isPlaying = false;
                clearTimeout(animationId);
            }
        }

        function updateSpeed(positionY) {
            const trackRect = speedTrack.getBoundingClientRect();
            const clampedY = Math.max(trackRect.top, Math.min(positionY, trackRect.bottom));
            let ratio = (clampedY - trackRect.top) / trackRect.height;
            ratio = Math.max(0, Math.min(1, ratio));
            
            frameDelay = minDelay + (maxDelay - minDelay) * ratio;
            speedThumb.style.top = `${ratio * 100}%`;
        }

        // 滑块与图片同步延迟动画（减小延迟）
        function updateFrameThumbPositionWithDelay(targetIdx) {
            if (frameAnimationFrame) {
                cancelAnimationFrame(frameAnimationFrame);
            }
            
            // 计算目标位置百分比
            const targetRatio = (targetIdx - 1) / 11;
            const targetTopPercent = 100 - (targetRatio * 100);
            const currentTopPercent = parseFloat(frameThumb.style.top) || 100;
            
            function animate() {
                const current = parseFloat(frameThumb.style.top) || 100;
                const difference = targetTopPercent - current;
                
                if (Math.abs(difference) < 0.8) { // 增大阈值，更快到达目标
                    frameThumb.style.top = `${targetTopPercent}%`;
                    frameAnimationFrame = null;
                    return;
                }
                
                // 增大每步移动距离，减小延迟感
                const next = current + (difference / frameTransitionSpeed);
                frameThumb.style.top = `${next}%`;
                frameAnimationFrame = requestAnimationFrame(animate);
            }
            
            animate();
        }

        // 拖动时更新目标帧
        function updateFrameByPosition(positionY) {
            const trackRect = frameTrack.getBoundingClientRect();
            const clampedY = Math.max(trackRect.top, Math.min(positionY, trackRect.bottom));
            let ratio = (clampedY - trackRect.top) / trackRect.height;
            ratio = Math.max(0, Math.min(1, ratio));
            
            // 更新目标帧
            targetIndex = Math.round(1 + (11 * (1 - ratio)));
            frameThumb.style.top = `${ratio * 100}%`;
            
            // 拖动时直接更新图片，减少延迟感
            if (isFrameDragging) {
                currentIndex = targetIndex;
                imgElement.src = `${currentIndex}.png`;
            }
        }

        // 初始化滑块位置
        const initialRatio = (frameDelay - minDelay) / (maxDelay - minDelay);
        speedThumb.style.top = `${initialRatio * 100}%`;
        frameThumb.style.top = '100%';

        // 事件监听
        speedTrack.addEventListener('mousedown', (e) => {
            e.preventDefault();
            isDragging = true;
            updateSpeed(e.clientY);
        });

        speedThumb.addEventListener('mousedown', (e) => {
            e.preventDefault();
            isDragging = true;
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                e.preventDefault();
                updateSpeed(e.clientY);
            } else if (isFrameDragging) {
                e.preventDefault();
                updateFrameByPosition(e.clientY);
            }
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            isFrameDragging = false;
        });

        speedTrack.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDragging = true;
            updateSpeed(e.touches[0].clientY);
        });

        speedThumb.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDragging = true;
        });

        document.addEventListener('touchmove', (e) => {
            if (isDragging) {
                e.preventDefault();
                updateSpeed(e.touches[0].clientY);
            } else if (isFrameDragging) {
                e.preventDefault();
                updateFrameByPosition(e.touches[0].clientY);
            }
        });

        document.addEventListener('touchend', () => {
            isDragging = false;
            isFrameDragging = false;
        });

        frameTrack.addEventListener('mousedown', (e) => {
            e.preventDefault();
            isFrameDragging = true;
            updateFrameByPosition(e.clientY);
        });

        frameThumb.addEventListener('mousedown', (e) => {
            e.preventDefault();
            isFrameDragging = true;
        });

        frameTrack.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isFrameDragging = true;
            updateFrameByPosition(e.touches[0].clientY);
        });

        frameThumb.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isFrameDragging = true;
        });

        // 播放控制
        container.addEventListener('mousedown', startPlay);
        container.addEventListener('mouseup', stopPlay);
        container.addEventListener('mouseleave', stopPlay);

        container.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startPlay();
        });
        container.addEventListener('touchend', (e) => {
            e.preventDefault();
            stopPlay();
        });

        // 横屏提示
        window.addEventListener('resize', () => {
            const isLandscape = window.innerWidth > window.innerHeight;
            document.querySelector('.hint').textContent = isLandscape 
                ? '长按屏幕开操，松手停止' 
                : '请旋转屏幕至横屏 → 长按任意位置惩罚妹妹，松手停止';
        });
    </script>  
 </body>
</html>